import { cssBundleHref } from '@remix-run/css-bundle'
import { json, type DataFunctionArgs, type HeadersFunction, type MetaFunction } from '@remix-run/node'
import { Links, LiveReload, Meta, Outlet, Scripts, ScrollRestoration, useLoaderData } from '@remix-run/react'
import { withSentry } from '@sentry/remix'
import tailwindStyleSheetUrl from './styles/tailwind.css'
import { authenticator, getUserId } from './utils/auth.server.ts'
import { ClientHintCheck, getHints } from './utils/client-hints.tsx'
import { getConfetti } from './utils/confetti.server.ts'
import { prisma } from './utils/db.server.ts'
import { getEnv } from './utils/env.server.ts'
import { combineHeaders, getDomainUrl } from './utils/misc.tsx'
import { useNonce } from './utils/nonce-provider.ts'
import { makeTimings, time } from './utils/timing.server.ts'
import { getToast } from './utils/toast.server.ts'
import { HTML5Backend } from 'react-dnd-html5-backend'
import { DndProvider } from 'react-dnd'
import { MantineProvider, ColorSchemeScript, CSSVariablesResolver, MantineTheme } from '@mantine/core'
import { ModalsProvider } from '@mantine/modals'
import { Notifications } from '@mantine/notifications'
import { theme } from './theme.ts'
import '@mantine/core/styles.css'
import '@mantine/dates/styles.css'
import '@mantine/notifications/styles.css'
import 'remixicon/fonts/remixicon.css'
import { RecoilRoot } from 'recoil'
import { registerCustomType } from 'remix-typedjson'
import { DateObjectUnits, DateTime } from 'luxon'

// Register custom types for remix-typedjson
registerCustomType({
  type: 'luxon',
  is: (value: unknown) => value instanceof DateTime,
  serialize: (value: DateTime) => JSON.stringify(value.toObject()),
  deserialize: (value: string) => DateTime.fromObject(JSON.parse(value) as DateObjectUnits), // This will always hold because its generated by .toObject()
})

export const links = () => {
  return [
    // Preload svg sprite as a resource to avoid render blocking
    // { rel: 'preload', href: iconsHref, as: 'image' },
    // Preload CSS as a resource to avoid render blocking
    { rel: 'preload', href: tailwindStyleSheetUrl, as: 'style' },
    cssBundleHref ? { rel: 'preload', href: cssBundleHref, as: 'style' } : null,
    { rel: 'mask-icon', href: '/favicons/mask-icon.svg' },
    {
      rel: 'alternate icon',
      type: 'image/png',
      href: '/favicons/favicon-32x32.png',
    },
    { rel: 'apple-touch-icon', href: '/favicons/apple-touch-icon.png' },
    {
      rel: 'manifest',
      href: '/site.webmanifest',
      crossOrigin: 'use-credentials',
    } as const, // necessary to make typescript happy
    //These should match the css preloads above to avoid css as render blocking resource
    { rel: 'icon', type: 'image/svg+xml', href: '/favicons/favicon.svg' },
    { rel: 'stylesheet', href: tailwindStyleSheetUrl },
    cssBundleHref ? { rel: 'stylesheet', href: cssBundleHref } : null,
  ].filter(Boolean)
}

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  return [{ title: data ? 'Example' : 'Error | Example' }]
}

export async function loader({ request }: DataFunctionArgs) {
  const timings = makeTimings('root loader')
  const userId = await time(() => getUserId(request), {
    timings,
    type: 'getUserId',
    desc: 'getUserId in root',
  })

  const user = userId
    ? await time(
        () =>
          prisma.user.findUniqueOrThrow({
            select: {
              id: true,
              name: true,
              username: true,
            },
            where: { id: userId },
          }),
        { timings, type: 'find user', desc: 'find user in root' },
      )
    : null
  if (userId && !user) {
    console.info('something weird happened')
    // something weird happened... The user is authenticated but we can't find
    // them in the database. Maybe they were deleted? Let's log them out.
    await authenticator.logout(request, { redirectTo: '/' })
  }
  const { toast, headers: toastHeaders } = await getToast(request)
  const { confettiId, headers: confettiHeaders } = getConfetti(request)

  return json(
    {
      user,
      requestInfo: {
        hints: getHints(request),
        origin: getDomainUrl(request),
        path: new URL(request.url).pathname,
        userPrefs: {
          theme: 'light',
        },
      },
      ENV: getEnv(),
      toast,
      confettiId,
    },
    {
      headers: combineHeaders({ 'Server-Timing': timings.toString() }, toastHeaders, confettiHeaders),
    },
  )
}

export const headers: HeadersFunction = ({ loaderHeaders }) => {
  const headers = {
    'Server-Timing': loaderHeaders.get('Server-Timing') ?? '',
  }
  return headers
}

const cssVarResolver: CSSVariablesResolver = (theme: MantineTheme) => {
  // Add all variables in theme.other as CSS variables. Nesting is supported.
  // e.g. theme.other.layout.aside.width => --mantine-layout-aside-width (note that 'other' is skipped)
  const variables: Record<string, string> = {}
  const light: Record<string, string> = {}
  const dark: Record<string, string> = {}

  const flattenObject = (obj: any, prefix = ''): Record<string, string> => {
    return Object.keys(obj).reduce((acc: Record<string, string>, k: string) => {
      const pre = prefix.length ? prefix + '-' : ''
      if (typeof obj[k] === 'object') Object.assign(acc, flattenObject(obj[k], pre + k))
      else acc[pre + k] = obj[k]
      return acc
    }, {})
  }

  const flattenedOther = flattenObject(theme.other)

  for (const key in flattenedOther) {
    const cssVarName = `--mantine-${key}`
    variables[cssVarName] = flattenedOther[key]
  }

  return { variables, dark, light }
}

function Document({
  children,
  nonce,
  env = {},
}: {
  children: React.ReactNode
  nonce: string
  env?: Record<string, string>
}) {
  return (
    <html lang="en" className="h-full overflow-x-hidden">
      <head>
        <ClientHintCheck nonce={nonce} />
        <Meta />
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <Links />
        <ColorSchemeScript nonce={nonce} defaultColorScheme="light" />
      </head>
      <body className="bg-background text-foreground">
        <MantineProvider theme={theme} defaultColorScheme="light" cssVariablesResolver={cssVarResolver}>
          <Notifications />
          <ModalsProvider>
            <DndProvider backend={HTML5Backend}>
              <RecoilRoot>{children}</RecoilRoot>
            </DndProvider>
          </ModalsProvider>
        </MantineProvider>
        <script
          nonce={nonce}
          dangerouslySetInnerHTML={{
            __html: `window.ENV = ${JSON.stringify(env)}`,
          }}
        />
        <ScrollRestoration nonce={nonce} />
        <Scripts nonce={nonce} />
        <LiveReload nonce={nonce} />
      </body>
    </html>
  )
}

function App() {
  const nonce = useNonce()

  // Get root loader data
  const rootData = useLoaderData<typeof loader>()

  return (
    <Document nonce={nonce} env={rootData.ENV}>
      <Outlet />
    </Document>
  )
}
export default withSentry(App)

export function ErrorBoundary() {
  // the nonce doesn't rely on the loader so we can access that
  const nonce = useNonce()

  // NOTE: you cannot use useLoaderData in an ErrorBoundary because the loader
  // likely failed to run so we have to do the best we can.
  // We could probably do better than this (it's possible the loader did run).
  // This would require a change in Remix.

  // Just make sure your root route never errors out and you'll always be able
  // to give the user a better UX.

  return (
    <Document nonce={nonce}>
      <div>error</div>
    </Document>
  )
}
